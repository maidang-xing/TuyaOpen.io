"use strict";(self.webpackChunktuyaopen_io_website=self.webpackChunktuyaopen_io_website||[]).push([["6258"],{7287:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,default:()=>u,frontMatter:()=>d,contentTitle:()=>o,toc:()=>l,assets:()=>s});var t=JSON.parse('{"id":"peripheral/audio","title":"Audio Driver","description":"Overview","source":"@site/docs/peripheral/audio.md","sourceDirName":"peripheral","slug":"/peripheral/audio","permalink":"/docs/peripheral/audio","draft":false,"unlisted":false,"editUrl":"https://github.com/Tuya-Community/TuyaOpen.io/edit/master/docs/peripheral/audio.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Display Driver","permalink":"/docs/peripheral/display"},"next":{"title":"Button Driver","permalink":"/docs/peripheral/button"}}'),a=i(4848),r=i(8453);let d={},o="Audio Driver",s={},l=[{value:"Overview",id:"overview",level:2},{value:"Fundamental concepts",id:"fundamental-concepts",level:2},{value:"Audio connection architecture",id:"audio-connection-architecture",level:2},{value:"Hardware architecture for audio devices with a built-in codec",id:"hardware-architecture-for-audio-devices-with-a-built-in-codec",level:3},{value:"Hardware architecture for audio devices with an external codec",id:"hardware-architecture-for-audio-devices-with-an-external-codec",level:3},{value:"Functional modules",id:"functional-modules",level:2},{value:"Abstract management module (Tuya Driver Layer - TDL)",id:"abstract-management-module-tuya-driver-layer---tdl",level:3},{value:"Instantiation &amp; registration module (Tuya Device Driver - TDD)",id:"instantiation--registration-module-tuya-device-driver---tdd",level:3},{value:"Features",id:"features",level:2},{value:"Supported peripherals",id:"supported-peripherals",level:2},{value:"Workflow",id:"workflow",level:2},{value:"Development guide",id:"development-guide",level:2},{value:"Kconfig configuration",id:"kconfig-configuration",level:3},{value:"Runtime environment",id:"runtime-environment",level:3},{value:"Scenario 1: Enabled by default for the target board",id:"scenario-1-enabled-by-default-for-the-target-board",level:4},{value:"Scenario 2: Enabled as a dependency by another feature that requires the audio driver",id:"scenario-2-enabled-as-a-dependency-by-another-feature-that-requires-the-audio-driver",level:4},{value:"Scenario 3: Manually enable the macro",id:"scenario-3-manually-enable-the-macro",level:4},{value:"How to use",id:"how-to-use",level:3},{value:"Adapt an audio driver",id:"adapt-an-audio-driver",level:4},{value:"Register an audio device",id:"register-an-audio-device",level:4},{value:"Control the device",id:"control-the-device",level:4},{value:"API description",id:"api-description",level:2},{value:"Configure structure",id:"configure-structure",level:3},{value:"Register structure",id:"register-structure",level:3},{value:"Register an audio device",id:"register-an-audio-device-1",level:3},{value:"Register an audio driver",id:"register-an-audio-driver",level:3},{value:"Locate and manage a device",id:"locate-and-manage-a-device",level:3},{value:"Power on a device",id:"power-on-a-device",level:3},{value:"Power off a device",id:"power-off-a-device",level:3},{value:"Adjust the volume",id:"adjust-the-volume",level:3},{value:"Control audio playback",id:"control-audio-playback",level:3},{value:"Stop audio playback",id:"stop-audio-playback",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"audio-driver",children:"Audio Driver"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/tuya/TuyaOpen/tree/master/src/peripherals/audio_codecs",children:"audio driver"})," is a core component within TuyaOpen responsible for handling audio input and output. It provides a unified interface to manage different types of audio devices, such as microphones and speakers. Through this driver, applications can easily perform audio capture, playback, and configuration without needing to manage the specific implementation details of the underlying hardware."]}),"\n",(0,a.jsx)(n.h2,{id:"fundamental-concepts",children:"Fundamental concepts"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Term"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Definition"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Microphone (MIC)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A microphone is a transducer that converts sound signals into electrical signals."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Speaker (SPK)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A speaker is a device that converts electrical signals into sound signals."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Codec"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["A codec typically consists of two main parts:",(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)(n.strong,{children:"Encoder"}),": Converts raw data (like uncompressed audio or video) into another format for easier storage or transmission."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)(n.strong,{children:"Decoder"}),": Restores encoded data to its original format for playback or viewing."]})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Power amplifier (PA)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"An electronic component that amplifies a weak input signal to drive higher-power loads, such as speakers or antennas."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Pulse code modulation (PCM)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"An encoding method that converts analog audio signals into digital signals. Raw PCM data (often called PCM raw stream or raw data) is uncompressed and requires decoding for playback."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Pulse density modulation (PDM)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"A digital audio encoding method characterized by having only one bit of data, using the density of pulses to represent the intensity of the analog signal."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Inter-integrated circuit (I2C)"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Primarily used for transmitting control signals, configuration parameters, and small amounts of data between chips. Two wires are used for communication, including SDA (serial data) and SCL (serial clock)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Inter-IC sound (I2S)"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["Specifically designed for digital audio data transmission. Uses at least three lines:",(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Serial clock (SCK)"}),(0,a.jsx)("li",{children:"Word select (WS)"}),(0,a.jsx)("li",{children:"Serial data (SD)"})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Analog-to-digital converter (ADC)"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["Converts analog signals (such as sound, light, and temperature) into digital signals for processing, storage, or transmission by computers or other digital systems. ",(0,a.jsx)("br",{}),"The ",(0,a.jsx)(n.code,{children:"analog-to-digital"})," conversion process typically involves sampling, quantization, and encoding (such as PCM)."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Digital-to-analog converter (DAC)"}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:["Converts digital signals (such as, from computers and MP3 players) into analog signals to drive analog devices like speakers or displays. ",(0,a.jsx)("br",{}),"The ",(0,a.jsx)(n.code,{children:"digital-to-analog"})," conversion process generates corresponding analog voltage or current outputs based on the digital input values."]})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"audio-connection-architecture",children:"Audio connection architecture"}),"\n",(0,a.jsxs)(n.p,{children:["The audio connection architecture varies depending on the main controller chip. For example, the ",(0,a.jsx)(n.code,{children:"T5AI"})," includes built-in ADC and DAC interfaces and can implement an audio system without a codec chip. In contrast, the ",(0,a.jsx)(n.code,{children:"ESP32-S3"})," does not support DAC and requires an external codec chip to build an audio system."]}),"\n",(0,a.jsx)(n.h3,{id:"hardware-architecture-for-audio-devices-with-a-built-in-codec",children:"Hardware architecture for audio devices with a built-in codec"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\nsubgraph mic ["Microphone"]\nmicrophone[" Microphone "]\nend\n\nsubgraph esp32 ["MCU"]\nesp_adc["ADC"]\nesp_dac["DAC"]\npa_gpio["PA_GPIO"]\nend\n\nsubgraph ns4150 ["PA"]\nns_in["IN"]\namp["AMP"]\nns_out["OUT"]\nns_ctrl["CTRL"]\n\n%% PA internal connection\nns_in --\x3e amp\namp --\x3e ns_out\nend\n\nsubgraph speaker_box ["Speaker"]\nspeaker["Speaker"]\nend\n\nmicrophone --\x3e|"ADC Capture audio signals"| esp_adc\nesp_dac --\x3e|"DAC Output audio signal"| ns_in\nns_out --\x3e|"Audio output"| speaker\npa_gpio --\x3e|"Control signals"| ns_ctrl\n'}),"\n",(0,a.jsx)(n.h3,{id:"hardware-architecture-for-audio-devices-with-an-external-codec",children:"Hardware architecture for audio devices with an external codec"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\nsubgraph mic [" Microphone "]\nmicrophone["Microphone"]\nend\n\nsubgraph codec [" CODEC "]\nadc["ADC"]\ndac["DAC"]\ni2s_port["I2S"]\ni2c_port["I2C"]\n\n%% Codec internal connection\nadc --\x3e|"Data channels"| i2s_port\ni2s_port --\x3e|"Data channels"| dac\nend\n\nsubgraph mcu [" MCU "]\ni2s_bus["I2S"]\ni2c_bus["I2C"]\npa_gpio["PA_GPIO"]\nend\n\nsubgraph amplifier [" PA "]\nns_in["IN"]\namp["AMP"]\nns_out["OUT"]\nns_ctrl["CTRL"]\n\n%% PA internal connection\nns_in --\x3e amp\namp --\x3e ns_out\nend\n\nsubgraph speaker_box ["Speaker"]\nspeaker["Speaker"]\nend\n\nmicrophone --\x3e|"ADC Capture audio signals"| adc\ndac --\x3e|"DAC Output audio signal"| ns_in\ni2c_bus --\x3e|"I2C communication"| i2c_port\ni2s_bus --\x3e|"I2S Data (PCM coded)"| i2s_port\nns_out --\x3e|"Audio output"| speaker\npa_gpio --\x3e|"Control signals"| ns_ctrl\n'}),"\n",(0,a.jsx)(n.h2,{id:"functional-modules",children:"Functional modules"}),"\n",(0,a.jsx)(n.p,{children:"TuyaOpen aims to deliver a standardized, platform-agnostic audio solution. Its core design philosophy centers on layered decoupling, effectively separating the audio requirements of the application layer from the specific hardware implementations at the underlying level."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"For application developers"}),": Regardless of whether the underlying hardware utilizes the T5AI chip or another chip's audio codec, the application layer only needs to invoke a single set of unified, standardized APIs (the ",(0,a.jsx)(n.code,{children:"tdl_audio_xxx"})," function series), such as ",(0,a.jsx)(n.code,{children:"tdl_audio_open"})," and ",(0,a.jsx)(n.code,{children:"tdl_audio_play"}),". This significantly reduces development complexity and enhances code portability."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"For driver developers"}),": When adding support for a new audio chip, developers simply need to adhere to the standard interface defined in ",(0,a.jsx)(n.code,{children:"tdl_audio_driver.h"})," to write a new TDD-layer driver (similar to ",(0,a.jsx)(n.code,{children:"tdd_audio.c"}),"), and then register it with the TDL management layer. This process requires no modifications to any application-layer code."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"abstract-management-module-tuya-driver-layer---tdl",children:"Abstract management module (Tuya Driver Layer - TDL)"}),"\n",(0,a.jsx)(n.p,{children:"This is the highest level of abstraction, providing unified audio service interfaces to the application layer."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tdl_audio_manage.c/h"}),": Implements the core logic for audio driver management. It maintains a linked list for registering and managing audio device drivers of different types (or for different platforms). Applications use functions like ",(0,a.jsx)(n.code,{children:"tdl_audio_find"})," and ",(0,a.jsx)(n.code,{children:"tdl_audio_open"})," to access audio functionality without being concerned with the underlying implementation details."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tdl_audio_driver.h"}),": Defines the standardized interface (",(0,a.jsx)(n.code,{children:"TDD_AUDIO_INTFS_T"}),") that all audio device drivers must adhere to. This includes function pointers for operations like ",(0,a.jsx)(n.code,{children:"open"}),", ",(0,a.jsx)(n.code,{children:"play"}),", ",(0,a.jsx)(n.code,{children:"config"}),", and ",(0,a.jsx)(n.code,{children:"close"}),". This ensures that ",(0,a.jsx)(n.code,{children:"tdl_audio_manage"})," can uniformly interact with any underlying driver that conforms to this standard."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"instantiation--registration-module-tuya-device-driver---tdd",children:"Instantiation & registration module (Tuya Device Driver - TDD)"}),"\n",(0,a.jsx)(n.p,{children:"This is the driver's intermediate layer, containing the concrete implementations for specific hardware platforms."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"tdd_audio.c/h"}),": Implements the audio driver for different platforms. It acts as a bridge, fulfilling the ",(0,a.jsx)(n.code,{children:"TDD_AUDIO_INTFS_T"})," standard interface defined by the upper TDL layer, while calling the TKL layer or the hardware abstraction interfaces provided by the chip vendor to control the actual hardware. The ",(0,a.jsx)(n.code,{children:"tdd_audio_register"})," function registers this driver's implementation (function pointers) with the TDL layer."]}),"\n",(0,a.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Audio input (microphone capture)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Start and stop: Audio capture can be started and stopped using ",(0,a.jsx)(n.code,{children:"tdl_audio_open"})," and ",(0,a.jsx)(n.code,{children:"tdl_audio_close"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Asynchronous data callback: The driver employs a callback mechanism (",(0,a.jsx)(n.code,{children:"TDL_AUDIO_MIC_CB"}),") to push captured audio data to the application layer in real-time, frame by frame. The application layer passively receives data instead of proactively polling, leading to higher efficiency."]}),"\n",(0,a.jsxs)(n.li,{children:["Status notification: The callback function delivers not only audio data but also the current status (",(0,a.jsx)(n.code,{children:"TDL_AUDIO_STATUS_E"}),'), such as notifying the application of "Voice Activity Detected (',(0,a.jsx)(n.code,{children:"VAD_START"}),')" or "Voice Activity Ended (',(0,a.jsx)(n.code,{children:"VAD_END"}),')".']}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Audio output (speaker playback)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Play audio stream: The application layer can send audio data blocks (for example, in PCM format) to the driver via the ",(0,a.jsx)(n.code,{children:"tdl_audio_play"})," function, which then routes them to the hardware for playback."]}),"\n",(0,a.jsxs)(n.li,{children:["Playback control: Playback can be stopped immediately by calling ",(0,a.jsx)(n.code,{children:"tdl_audio_play_stop"})," at any time to clear the playback buffer."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Volume control"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Set volume: The playback volume of the speaker can be adjusted dynamically (ranging from 0 to 100) at runtime using the ",(0,a.jsx)(n.code,{children:"tdl_audio_volume_set"})," function."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Acoustic echo cancellation (AEC)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Configurable AEC: During audio device initialization, you can choose to enable or disable the AEC function (requires hardware support) through a configuration option (",(0,a.jsx)(n.code,{children:"aec_enable"}),")."]}),"\n",(0,a.jsx)(n.li,{children:"Enhanced call experience: AEC is a key technology for achieving full-duplex voice calls (simultaneous speaking and listening without producing echo). The driver's built-in AEC support enables it to meet the demands of advanced applications like voice chats and video calls."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Extensible driver management"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Dynamic registration and discovery: The system can register multiple different audio drivers simultaneously (such as an onboard codec and an external USB sound card)."}),"\n",(0,a.jsxs)(n.li,{children:["Lookup by name: The application layer can look up and obtain the handle to a specific audio device (",(0,a.jsx)(n.code,{children:"tdl_audio_find"}),") using a string name (such as ",(0,a.jsx)(n.code,{children:"audio_codec"}),"). Therefore, you can easily find the desired devices."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"supported-peripherals",children:"Supported peripherals"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"Codec"}),(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"Audio recording"}),(0,a.jsx)(n.th,{style:{textAlign:"center"},children:"Playback"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8311"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8388"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"ES8389"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"center"},children:"\u2026"}),(0,a.jsx)(n.td,{style:{textAlign:"center"}}),(0,a.jsx)(n.td,{style:{textAlign:"center"}})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"workflow",children:"Workflow"}),"\n",(0,a.jsx)(n.p,{children:"Using the T5AI as an example, this section describes how the audio driver framework works."}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant App as App\n    participant TAL as Audio Abstraction Layer\n    participant TDD as Audio Device Driver\n    participant Bd as Board-level Configuration\n\n    Note over App, Bd: Register audio device\n\n    Bd->>+TDD: Call tdd_audio_register\n    Note right of Bd: Pass AUDIO_CODEC_NAME<br/>Pass TDD_AUDIO_T5AI_T config parameters<br/>- ai_chn: TKL_AI_0<br/>- sample_rate: TKL_AUDIO_SAMPLE_16K<br/>- data_bits: TKL_AUDIO_DATABITS_16<br/>- channel: TKL_AUDIO_CHANNEL_MONO<br/>- spk_pin: BOARD_SPEAKER_EN_PIN<br/>- aec_enable: 0/1\n\n    TDD->>+TAL: Call tdl_audio_driver_register\n    Note right of TDD: Register device name<br/>Register audio interface (TDD_AUDIO_INTFS_T)<br/>- __tdd_audio_open<br/>- __tdd_audio_close<br/>- __tdd_audio_play<br/>- __tdd_audio_config<br/>- __tdd_audio_set_volume\n\n    Note over TAL: Create an audio node (TDL_AUDIO_NODE_T)<br/> Add the node to the audio list (__audio_node_add)\n\n    TAL--\x3e>-TDD: Return registration results\n    TDD--\x3e>-Bd: Return registration results\n\n    Note over App, Bd: Get audio device handle\n\n    App->>+TAL: Call tdl_audio_find\n    Note over TAL: Find the audio device in the list by device name<br/>Return the audio node handle\n    TAL--\x3e>-App: Return the audio device handle\n\n    Note over App, Bd: Power on audio device\n\n    App->>+TAL: Call tdl_audio_open\n    TAL->>+TDD: Call __tdd_audio_open\n    Note right of TDD: Initialize audio hardware<br/>Configure ADC/DAC parameters<br/>Set I2S interface<br/>Configure speaker enable pin\n    TDD--\x3e>-TAL: Return the power-on result\n    TAL--\x3e>-App: Return the device power-on result\n\n    Note over App, Bd: Configure audio parameters\n\n    App->>+TAL: Call the audio configuration interface\n    TAL->>+TDD: Call __tdd_audio_config\n    Note right of TDD: Set sample rate<br/> Set data bit depth<br/> Set channel configuration<br/> Configure echo cancellation (if enabled)\n    TDD--\x3e>-TAL: Return configuration results\n    TAL--\x3e>-App: Return configuration results\n\n    Note over App, Bd: Set volume\n\n    App->>+TAL: Call tdl_audio_volume_set\n    TAL->>+TDD: Call __tdd_audio_set_volume\n    Note right of TDD: Adjust audio output volume<br/>Control speaker amplifier\n    TDD--\x3e>-TAL: Return the volume setting result\n    TAL--\x3e>-App: Return the volume setting result\n\n    Note over App, Bd: Play back audio\n\n    App->>+TAL: Call tdl_audio_play\n    Note right of App: Pass audio frame data<br/>Pass frame format (TDL_AUDIO_FRAME_FORMAT_E)\n    TAL->>+TDD: Call __tdd_audio_play\n    TAL->>TDD: Call __tkl_audio_frame_put\n    Note right of TDD: Process audio frame data<br/> Output to DAC/I2S<br/> Control speaker enable\n    TDD--\x3e>-TAL: Return playback results\n    TAL--\x3e>-App: Return playback results\n\n    Note over App, Bd: Stop audio playback\n\n    App->>+TAL: Call tdl_audio_play_stop\n    TAL->>+TDD: Stop audio playback\n    Note right of TDD: Stop audio output<br/>Disable speakers\n    TDD--\x3e>-TAL: Return results of stopping audio playback\n    TAL--\x3e>-App: Return results of stopping audio playback\n\n    Note over App, Bd: Power off audio device\n\n    App->>+TAL: Call tdl_audio_close\n    TAL->>+TDD: Call __tdd_audio_close\n    Note right of TDD: Deinitialize audio hardware<br/> Release I2S resources<br/>Disable speaker pins\n    TDD--\x3e>-TAL: Return power-off results\n    TAL--\x3e>-App: Return the device power-off result\n"}),"\n",(0,a.jsx)(n.h2,{id:"development-guide",children:"Development guide"}),"\n",(0,a.jsx)(n.h3,{id:"kconfig-configuration",children:"Kconfig configuration"}),"\n",(0,a.jsxs)(n.p,{children:["To include the driver in the build, verify that the relevant ",(0,a.jsx)(n.code,{children:"Kconfig"})," options are enabled before building. In your target project directory, run ",(0,a.jsx)(n.code,{children:"tos.py config menu"})," on the terminal and check the following configuration options:"]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Macro"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"enable audio codecs"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Boolean"}),(0,a.jsx)(n.td,{children:"The driver code is included in the compilation only when this macro is enabled."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"audio support AEC"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Boolean"}),(0,a.jsx)(n.td,{children:"Enables the AEC feature (requires hardware support)."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"the name of audio codec"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"String"}),(0,a.jsx)(n.td,{children:"Configures the device name for the codec."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"the num of audio codecs"}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:"Integer"}),(0,a.jsx)(n.td,{children:"Configures the number of board-level codecs."})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"open_audio",src:i(8652).A+"",width:"681",height:"274"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["These configuration items must be supported in both ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/Kconfig"})," and ",(0,a.jsx)(n.code,{children:"boards/<target_platform>/<target_board>/Kconfig"})," (Check the ",(0,a.jsx)(n.code,{children:"Kconfig"})," file for your specific target board). If you cannot find the relevant configuration items, please review the contents of these two files."]})}),"\n",(0,a.jsx)(n.h3,{id:"runtime-environment",children:"Runtime environment"}),"\n",(0,a.jsxs)(n.p,{children:["To run this driver, you need to first enable the ",(0,a.jsx)(n.strong,{children:"master enable macro"})," (",(0,a.jsx)(n.code,{children:"ENABLE_AUDIO_CODECS"}),"). There are three scenarios where this macro becomes active: ",(0,a.jsx)(n.strong,{children:"Enabled by default for the target board"}),", ",(0,a.jsx)(n.strong,{children:"enabled as a dependency by another feature that requires the audio driver"}),", and ",(0,a.jsx)(n.strong,{children:"manually enabled"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"All subsequent commands must be executed from your target application directory. Do not run them from the TuyaOpen root directory or any other location, as this will cause errors."})}),"\n",(0,a.jsx)(n.h4,{id:"scenario-1-enabled-by-default-for-the-target-board",children:"Scenario 1: Enabled by default for the target board"}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"This applies when your selected development board comes with a pre-registered audio device. In this case, the board's source files already contain the necessary registration code."}),(0,a.jsxs)(n.p,{children:["Example: The TUYA_T5AI_EVB board supports both a microphone and a speaker. During its adaptation, the audio device was pre-registered, and the ",(0,a.jsx)(n.code,{children:"boards/T5AI/TUYA_T5AI_EVB/Kconfig"})," file includes the line ",(0,a.jsx)(n.code,{children:"select ENABLE_AUDIO_CODECS"}),". For specific sample code and configuration, refer to ",(0,a.jsx)(n.code,{children:"boards/T5AI/TUYA_T5AI_EVB"}),"."]})]}),"\n",(0,a.jsx)(n.p,{children:"The driver will be enabled automatically whenever this target board is selected."}),"\n",(0,a.jsxs)(n.p,{children:["Run the command to enter the ",(0,a.jsx)(n.code,{children:"Kconfig"})," menu interface."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"tos.py config menu\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["After executing ",(0,a.jsx)(n.code,{children:"select ENABLE_XXX"})," in ",(0,a.jsx)(n.code,{children:"boards/T5AI/TUYA_T5AI_EVB/Kconfig"}),", you cannot manually select/deselect it by executing ",(0,a.jsx)(n.code,{children:"tos.py config menu"}),"."]})}),"\n",(0,a.jsx)(n.h4,{id:"scenario-2-enabled-as-a-dependency-by-another-feature-that-requires-the-audio-driver",children:"Scenario 2: Enabled as a dependency by another feature that requires the audio driver"}),"\n",(0,a.jsx)(n.p,{children:"If you enable a feature that depends on the audio driver, the audio driver's enable macro will be activated automatically."}),"\n",(0,a.jsx)(n.h4,{id:"scenario-3-manually-enable-the-macro",children:"Scenario 3: Manually enable the macro"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Run the command to enter the ",(0,a.jsx)(n.code,{children:"Kconfig"})," menu interface."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"tos.py config menu\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Manually locate and enable the macro."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"open_audio",src:i(8652).A+"",width:"681",height:"274"})}),"\n",(0,a.jsx)(n.h3,{id:"how-to-use",children:"How to use"}),"\n",(0,a.jsx)(n.h4,{id:"adapt-an-audio-driver",children:"Adapt an audio driver"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["You can skip this step if a suitable driver for your audio hardware already exists in ",(0,a.jsx)(n.a,{href:"https://github.com/tuya/TuyaOpen/tree/master/boards/ESP32/common/audio",children:"tdd_audio"}),". If not, you can adapt an audio driver yourself by following this process:"]})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Create ",(0,a.jsx)(n.code,{children:"tdd_audio_xxx.c/h"})," files within ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/tdd_audio"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allocate memory"})," for the device and implement the abstract audio driver interfaces (function pointers such as ",(0,a.jsx)(n.code,{children:"open"}),", ",(0,a.jsx)(n.code,{children:"close"}),", ",(0,a.jsx)(n.code,{children:"play"}),", and ",(0,a.jsx)(n.code,{children:"config"}),") according to your specific hardware."]}),"\n",(0,a.jsxs)(n.li,{children:["Call the interface to ",(0,a.jsx)(n.strong,{children:"register a generic audio device node"})," (",(0,a.jsx)(n.code,{children:"tdl_audio_driver_register()"}),")."]}),"\n",(0,a.jsx)(n.li,{children:"Refer to the already adapted drivers for example implementation code."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"OPERATE_RET tdd_audio_register(char *name, TDD_AUDIO_T5AI_T cfg)\n{\n    OPERATE_RET rt = OPRT_OK;\n\n    TDD_AUDIO_DATA_HANDLE_T *_hdl = NULL;\n    TDD_AUDIO_INTFS_T intfs = {0};\n\n    /* Allocate memory to the device */\n    _hdl = (TDD_AUDIO_DATA_HANDLE_T *)tal_malloc(sizeof(TDD_AUDIO_DATA_HANDLE_T));\n    memset(_hdl, 0, sizeof(TDD_AUDIO_DATA_HANDLE_T));\n    g_tdd_audio_hdl = _hdl;\n    _hdl->play_volume = 80;\n    memcpy(&_hdl->cfg, &cfg, sizeof(TDD_AUDIO_T5AI_T));\n\n    /* Register function pointers */\n    intfs.open = __tdd_audio_open;\n    intfs.play = __tdd_audio_play;\n    intfs.config = __tdd_audio_config;\n    intfs.close = __tdd_audio_close;\n\n    tdl_audio_driver_register(name, &intfs, (TDD_AUDIO_HANDLE_T)_hdl);\n    return rt;\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["When adapting a driver for ESP32, you need to create new files under the ",(0,a.jsx)(n.code,{children:"boards/ESP32/common/audio"})," directory. Pre-adapted drivers for ESP32-compatible codec chips are also located in this path."]})}),"\n",(0,a.jsx)(n.h4,{id:"register-an-audio-device",children:"Register an audio device"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If your selected target board already has an audio device pre-registered, you only need to select that target board in the ",(0,a.jsx)(n.code,{children:"Kconfig"}),", and call the ",(0,a.jsx)(n.code,{children:"board_register_hardware()"})," interface in your application. This interface already includes the registration for the corresponding audio device."]})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Implement the registration interface based on the audio codec model and connection pins. It is recommended to place this implementation within the ",(0,a.jsx)(n.code,{children:"board_register_hardware()"})," interface, located at ",(0,a.jsx)(n.code,{children:"boards/<target_platform>/<target_board>/xxx.c"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Configure the device's basic information and call the registration interface within ",(0,a.jsx)(n.code,{children:"board_register_hardware()"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"OPERATE_RET __board_register_audio(void)\n{\n    /* Write your struct configuration information here */\n    /* begin */\n\n    /* end */\n    TUYA_CALL_ERR_RETURN(tdd_audio_register(AUDIO_CODEC_NAME, cfg));\n    return rt;\n}\n\nOPERATE_RET board_register_hardware(void)\n{\n	TUYA_CALL_ERR_LOG(__board_register_audio());\n	return rt;\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"control-the-device",children:"Control the device"}),"\n",(0,a.jsxs)(n.p,{children:["Utilize the TDL interfaces provided in ",(0,a.jsx)(n.code,{children:"src/peripherals/audio_codecs/tdl_audio/include/tdl_audio_manage.h"})," to control the audio device."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Locate the device handle by its device name."}),"\n",(0,a.jsx)(n.li,{children:"Power on and initialize the audio device."}),"\n",(0,a.jsx)(n.li,{children:"Power off the audio device and release associated resources."}),"\n",(0,a.jsx)(n.li,{children:"Dynamically adjust the audio output volume."}),"\n",(0,a.jsx)(n.li,{children:"Play audio data."}),"\n",(0,a.jsx)(n.li,{children:"Stop playing audio data."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For a concrete implementation example, refer to ",(0,a.jsx)(n.code,{children:"examples/multimedia/audio"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"api-description",children:"API description"}),"\n",(0,a.jsx)(n.h3,{id:"configure-structure",children:"Configure structure"}),"\n",(0,a.jsx)(n.p,{children:"Construct the hardware configuration information structure for the TDD layer. The following example uses the T5AI platform."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Audio device configuration structure for T5AI board.\n *\n * This structure contains all hardware configuration parameters for the audio device,\n * including sample rate, data bits, channels, speaker control pins, and AEC settings.\n */\ntypedef struct {\n    uint8_t aec_enable;\n    TKL_AI_CHN_E ai_chn;\n    TKL_AUDIO_SAMPLE_E sample_rate;\n    TKL_AUDIO_DATABITS_E data_bits;\n    TKL_AUDIO_CHANNEL_E channel;\n\n    // spk\n    TKL_AUDIO_SAMPLE_E spk_sample_rate;\n    int spk_pin;\n    int spk_pin_polarity;\n} TDD_AUDIO_T5AI_T;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"register-structure",children:"Register structure"}),"\n",(0,a.jsx)(n.p,{children:"To register a structure for your audio driver, you need to implement the corresponding function pointers based on your audio driver."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Audio driver interface structure.\n *\n * This structure contains function pointers for all audio operations, providing\n * a unified interface for the audio abstract layer to call driver functions.\n */\ntypedef struct {\n    OPERATE_RET (*open)(TDD_AUDIO_HANDLE_T handle, TDL_AUDIO_MIC_CB mic_cb);\n    OPERATE_RET (*play)(TDD_AUDIO_HANDLE_T handle, uint8_t *data, uint32_t len);\n    OPERATE_RET (*config)(TDD_AUDIO_HANDLE_T handle, TDD_AUDIO_CMD_E cmd, void *args);\n    OPERATE_RET (*close)(TDD_AUDIO_HANDLE_T handle);\n} TDD_AUDIO_INTFS_T;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"register-an-audio-device-1",children:"Register an audio device"}),"\n",(0,a.jsx)(n.p,{children:"Registering the audio device driver with the system is the entry point for the audio driver framework. By passing in the device name and configuration parameters, you add the audio device to the management list for use by the application."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Registers an audio device driver with the audio management system.\n *\n * This function registers an audio device driver including device name, hardware\n * configuration parameters, and driver interface functions. After successful\n * registration, applications can find and use the audio device by name.\n *\n * @param name Audio device name used for identification and lookup\n * @param cfg Audio device configuration parameters including sample rate, data bits,\n * channels, speaker pin configuration, etc.\n *\n * @return Returns OPRT_OK on successful registration, or an appropriate error code on failure.\n */\nOPERATE_RET tdd_audio_register(const char *name, TDD_AUDIO_T5AI_T cfg);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"register-an-audio-driver",children:"Register an audio driver"}),"\n",(0,a.jsx)(n.p,{children:"Register the underlying audio driver interface to the abstraction layer management system, create device nodes, and maintain the device list."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Registers audio device driver interfaces to the abstract layer management system.\n *\n * This function registers audio device driver interface functions to the audio abstract\n * layer management system, creates device nodes and adds them to the device management list\n * for upper layer application calls.\n *\n * @param name Audio device name\n * @param intfs Audio driver interface structure containing various operation function pointers\n *\n * @return Returns OPRT_OK on successful registration, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_driver_register(const char *name, TDD_AUDIO_INTFS_T *intfs);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"locate-and-manage-a-device",children:"Locate and manage a device"}),"\n",(0,a.jsx)(n.p,{children:"Based on the device name, locate the specified device handle in the list of registered audio devices. This is the key interface for gaining control of the device."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Finds an audio device by device name.\n *\n * This function searches for the corresponding audio device node in the registered\n * audio device list based on the device name, and returns a device handle for\n * subsequent operations.\n *\n * @param name Name of the audio device to find\n *\n * @return Returns audio device handle, or NULL if not found.\n */\nTDL_AUDIO_HANDLE_T tdl_audio_find(const char *name);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"power-on-a-device",children:"Power on a device"}),"\n",(0,a.jsx)(n.p,{children:"Power on and initialize the audio device, including hardware initialization, pin configuration, and other necessary operations, to make the device fully functional."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Opens and initializes an audio device.\n *\n * This function opens the specified audio device and initializes audio hardware\n * including ADC/DAC, I2S interface, speaker enable pins, etc. After successful\n * opening, the device enters a usable state.\n *\n * @param audio_hdl Audio device handle\n *\n * @return Returns OPRT_OK on successful opening, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_open(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"power-off-a-device",children:"Power off a device"}),"\n",(0,a.jsx)(n.p,{children:"Power off the audio device and release related resources, including cleaning up by deinitializing hardware and disabling pins."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Closes and deinitializes an audio device.\n *\n * This function closes the specified audio device and deinitializes audio hardware\n * including releasing I2S resources, disabling speaker pins, closing ADC/DAC, etc.\n * After closing, the device becomes unavailable and needs to be reopened for use.\n *\n * @param audio_hdl Audio device handle\n *\n * @return Returns OPRT_OK on successful closing, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_close(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"adjust-the-volume",children:"Adjust the volume"}),"\n",(0,a.jsx)(n.p,{children:"Dynamically adjust the audio output volume and control the speaker amplifier gain."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Sets audio output volume.\n *\n * This function adjusts the output volume of the audio device, controls the gain\n * of the speaker amplifier, and implements dynamic volume adjustment functionality.\n *\n * @param audio_hdl Audio device handle\n * @param volume Volume value, typically ranging from 0-100\n *\n * @return Returns OPRT_OK on successful setting, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_volume_set(TDL_AUDIO_HANDLE_T audio_hdl, uint8_t volume);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"control-audio-playback",children:"Control audio playback"}),"\n",(0,a.jsx)(n.p,{children:"Play audio data and output audio frames to the speaker through the hardware interface."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Plays audio data.\n *\n * This function sends audio frame data to the audio device for playback. Data is\n * output to the speaker through DAC or I2S interface. Supports different audio\n * frame formats.\n *\n * @param audio_hdl Audio device handle\n * @param frame_data Audio frame data pointer\n * @param frame_size Audio frame data size\n * @param format Audio frame format\n *\n * @return Returns OPRT_OK on successful playback, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_play(TDL_AUDIO_HANDLE_T audio_hdl, void *frame_data, uint32_t frame_size,\n                           TDL_AUDIO_FRAME_FORMAT_E format);\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"stop-audio-playback",children:"Stop audio playback"}),"\n",(0,a.jsx)(n.p,{children:"Stop the current audio playback, turn off the audio output, and mute the device."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Stops audio playback.\n *\n * This function stops the currently ongoing audio playback, closes audio output,\n * disables speaker amplifier, and puts the device into a mute state.\n *\n * @param audio_hdl Audio device handle\n *\n * @return Returns OPRT_OK on successful stopping, or an appropriate error code on failure.\n */\nOPERATE_RET tdl_audio_play_stop(TDL_AUDIO_HANDLE_T audio_hdl);\n\n"})})]})}function u(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8652:function(e,n,i){i.d(n,{A:()=>t});let t=i.p+"assets/images/open_audio-c2c194ce0d4a362f5128872aaafb961b.png"},8453:function(e,n,i){i.d(n,{R:()=>d,x:()=>o});var t=i(6540);let a={},r=t.createContext(a);function d(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);